import { track } from 'ripple';
import { buildData as buildRawData, unitmap } from 'common/data';
import { streamUpdates } from 'common/streaming';
import { Row } from './Row.ripple';

function createData(count) {
  const data = buildRawData(count);
  let row;

  for (let i = 0; i < data.length; i++) {
    row = data[i];
    row.availabilityStatus = track(row.availabilityStatus);
    row.price = track(row.price);
  }

  return data;
}

let stopStreaming = null;

export component App() {
  let rows = track([]);
  let selected = track(null);
  let unitSystem = track('metric');
  let isStreaming = track(false);

  let weightConversion = track(() => @unitSystem === 'metric' ? 1 : 2.20462);
  let powerConversion = track(() => @unitSystem === 'metric' ? 1 : 0.00134102);
  let lengthConversion = track(() => @unitSystem === 'metric' ? 1 : 0.393701);

  <main>
    <div class="header">
      <h1>{"Ripple"}</h1>
      <div class="actions">
        <button id="create" disabled={@isStreaming} onClick={() => {
          if (stopStreaming) {
            stopStreaming();
            stopStreaming = null;
            @isStreaming = false;
          }
          @rows = createData(1000);
        }}>{"Create"}</button>
        <button id="stream" onClick={() => {
          if (stopStreaming) {
            stopStreaming();
            stopStreaming = null;
            @isStreaming = false;
            return;
          }
          const initialRows = createData(25);
          @isStreaming = true;
          @rows = initialRows;

          const idMap = new Map();
          for (const row of initialRows) {
            idMap.set(row.id, row);
          }

          stopStreaming = streamUpdates((updates) => {
            for (const update of updates) {
              const row = idMap.get(update.id);
              if (row) {
                if (update.price) row.@price = update.price;
                if (update.availabilityStatus) row.@availabilityStatus = update.availabilityStatus;
              }
            }
          });
        }}>{@isStreaming ? 'Stop' : 'Stream'}</button>
        <button id="reverse" disabled={@isStreaming} onClick={() => { @rows = @rows.toReversed(); }}>{"Reverse"}</button>
        <button id="insert" disabled={@isStreaming} onClick={() => { const items = @rows; @rows = items.slice(0, 10).concat(createData(1), items.slice(10)); }}>{"Insert"}</button>
        <button id="prepend" disabled={@isStreaming} onClick={() => { @rows = createData(1).concat(@rows); }}>{"Prepend"}</button>
        <button id="append" disabled={@isStreaming} onClick={() => { const items = @rows.slice(); items.push(...createData(1)); @rows = items; }}>{"Append"}</button>
        <button id="sort" disabled={@isStreaming} onClick={() => { @rows = @rows.toSorted((a, b) => a.name.localeCompare(b.name)); }}>{"Sort"}</button>
        <button id="filter" disabled={@isStreaming} onClick={() => { @rows = @rows.filter((d) => d.id % 2); }}>{"Filter"}</button>
        <button id="units" disabled={@isStreaming} onClick={() => { @unitSystem = @unitSystem === 'imperial' ? 'metric' : 'imperial'; }}>{"Units"}</button>
        <button id="restock" disabled={@isStreaming} onClick={() => { @rows.forEach(r => { if (r.@availabilityStatus === "Out of Stock") { r.@availabilityStatus = "In Stock"; } }); }}>{"Restock"}</button>
        <button id="clear" disabled={@isStreaming} onClick={() => {
          if (stopStreaming) {
            stopStreaming();
            stopStreaming = null;
            @isStreaming = false;
          }
          @rows = [];
        }}>{"Clear"}</button>
      </div>
    </div>

    if (@rows.length) {
      <table>
        <thead>
          <tr>
            <th>{"id"}</th>
            <th>{"name"}</th>
            <th>{"weight"}</th>
            <th>{"dimensions"}</th>
            <th>{"power consumption"}</th>
            <th>{"price"}</th>
            <th>{"availability status"}</th>
            <th>{"rating"}</th>
            <th>{"actions"}</th>
          </tr>
        </thead>
        <tbody>
          for (const row of @rows) {
            <Row
              row={row}
              selected={@selected}
              isStreaming={@isStreaming}
              onSelect={(id) => { @selected = id; }}
              onDelete={(id) => { @rows = @rows.filter(r => r.id !== id); }}
              weightConversion={@weightConversion}
              unitSystem={@unitSystem}
              lengthConversion={@lengthConversion}
              powerConversion={@powerConversion}
            />
          }
        </tbody>
      </table>
    } else {
      <h2 class="text-center">{"No rows to show"}</h2>
    }
  </main>
}
